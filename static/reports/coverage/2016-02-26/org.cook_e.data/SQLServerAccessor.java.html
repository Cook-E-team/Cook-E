<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>SQLServerAccessor.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">debug</a> &gt; <a href="index.source.html" class="el_package">org.cook_e.data</a> &gt; <span class="el_source">SQLServerAccessor.java</span></div><h1>SQLServerAccessor.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2016 the Cook-E development team
 *
 * This file is part of Cook-E.
 *
 * Cook-E is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Cook-E is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Cook-E.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

package org.cook_e.data;

import android.os.StrictMode;
import android.util.Log;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.text.ParseException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Locale;
import java.util.Properties;

/**
 * This class implements methods for storing and accessing an external sqlserver database
 */
public class SQLServerAccessor implements SQLAccessor {
    /**
     * The tag used for logging
     */
<span class="fc" id="L45">    private static final String TAG = SQLServerAccessor.class.getSimpleName();</span>

    /**
     * The server domain name
     */
    private static final String DOMAIN = &quot;cook-e.database.windows.net&quot;;

    /**
     * The server port to connect on
     */
    private static final int PORT = 1433;

    /**
     * The database name
     */
    private static final String DATABASE = &quot;Cook-E&quot;;
    /**
     * The database username
     */
    private static final String USERNAME = &quot;ReadOnlyLogin&quot;;
    /**
     * The password
     */
    private static final String PASSWORD = &quot;A2305Bmcnsdf&quot;;

    private static final String RECIPE_TABLE_NAME = &quot;Recipes&quot;;
    private static final String BUNCH_TABLE_NAME = &quot;Bunches&quot;;
    private static final String BUNCH_RECIPE_TABLE_NAME = &quot;BunchRecipes&quot;;
    /**
     * SQL query that creates the recipe table if it does not exist
     */
<span class="fc" id="L76">    private static final String RECIPE_TABLE_CREATE = String.format(Locale.US, &quot;IF NOT EXISTS &quot; +</span>
                    &quot;(SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = N'%s') &quot; +
                    &quot;CREATE TABLE %s (id INTEGER PRIMARY KEY, name NVARCHAR(MAX) NOT NULL DEFAULT '', &quot; +
                    &quot;author NVARCHAR(MAX) NOT NULL DEFAULT '', description NVARCHAR(MAX) NOT NULL DEFAULT '');&quot;,
            RECIPE_TABLE_NAME, RECIPE_TABLE_NAME);
    /**
     * SQL query that creates the recipe-bunch relation table if it does note exist
     */
<span class="fc" id="L84">    private static final String BUNCH_RECIPE_TABLE_CREATE = String.format(Locale.US, &quot;IF NOT EXISTS &quot; +</span>
                    &quot;(SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = N'%s') &quot; +
                    &quot;CREATE TABLE %s (bunch_id INTEGER NOT NULL, recipe_id INTEGER NOT NULL, &quot; +
                    &quot;PRIMARY KEY (bunch_id, recipe_id));&quot;,
            BUNCH_RECIPE_TABLE_NAME, BUNCH_RECIPE_TABLE_NAME);

    /**
     * SQL query that creates the bunch table if it does not exist
     */
<span class="fc" id="L93">    private static final String BUNCH_TABLE_CREATE = String.format(Locale.US, &quot;IF NOT EXISTS &quot; +</span>
                    &quot;(SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = N'%s') &quot; +
                    &quot;CREATE TABLE %s (id INTEGER PRIMARY KEY, name NVARCHAR(MAX) NOT NULL DEFAULT '');&quot;,
            BUNCH_TABLE_NAME, BUNCH_TABLE_NAME);

    /**
     * Statement (with placeholders) for inserting a recipe
     */
    private static final String RECIPE_INSERT = &quot;INSERT INTO &quot; + RECIPE_TABLE_NAME +
            &quot; (id, name, author, description) VALUES (?, ?, ?, ?)&quot;;

    /**
     * Statement (with placeholders) for selecting a recipe based on its title and author
     */
    private static final String RECIPE_SELECT_TITLE_AUTHOR = &quot;SELECT id, name, author, description&quot; +
            &quot; FROM &quot; + RECIPE_TABLE_NAME + &quot; WHERE name = ? AND author = ?&quot;;
    /**
     * Statement (with placeholders) for selecting a recipe based on a name fragment
     */
    private static final String RECIPE_SELECT_LIKE = &quot;SELECT id, name, author, description FROM &quot;
            + RECIPE_TABLE_NAME + &quot; WHERE name LIKE ?&quot;;

    /**
     * Statement for selecting all recipes
     */
    private static final String RECIPE_SELECT_ALL = &quot;SELECT id, name, author, description FROM &quot;
            + RECIPE_TABLE_NAME;

    /**
     * Parser used for transforming strings to recipes and recipes to strings
     */
    private StorageParser mParser;

    /**
     * The database connection
     */
    private final Connection mConnection;

    /**
     * Prepared statement for inserting a recipe
     */
    private final PreparedStatement mRecipeInsertStatement;
    /**
     * Prepared statement for selecting a recipe by title and author
     */
    private final PreparedStatement mRecipeSelectStatement;
    /**
     * Prepared statement for selecting a recipe based on a name fragment
     */
    private final PreparedStatement mRecipeSelectLikeStatement;
    /**
     * Prepared statement for selecting all recipes
     */
    private final PreparedStatement mRecipeSelectAllStatement;

    /**
     * This counter is always one greater than the ID of the last inserted recipe. It is used to
     * assign non-duplicate IDs.
     */
    private long mRecipeCounter;

    /**
     * Constructor
     *
     * @param parser StorageParser that can transform strings to recipes and recipes to strings
     */
<span class="fc" id="L159">    public SQLServerAccessor(StorageParser parser) throws SQLException {</span>
<span class="fc" id="L160">        this.mParser = parser;</span>

<span class="fc" id="L162">        final Properties properties = new Properties();</span>
<span class="fc" id="L163">        properties.put(&quot;user&quot;, USERNAME);</span>
<span class="fc" id="L164">        properties.put(&quot;password&quot;, PASSWORD);</span>
<span class="fc" id="L165">        properties.put(&quot;encrypt&quot;, &quot;true&quot;);</span>
<span class="fc" id="L166">        properties.put(&quot;trustServerCertificate&quot;, &quot;false&quot;);</span>
<span class="fc" id="L167">        properties.put(&quot;hostNameInCertificate&quot;, &quot;*.database.windows.net&quot;);</span>
<span class="fc" id="L168">        properties.put(&quot;loginTimeout&quot;, 30);</span>
<span class="fc" id="L169">        final String dbUrl = &quot;jdbc:jtds:sqlserver://&quot; + DOMAIN + &quot;:&quot; + PORT + &quot;/&quot; + DATABASE;</span>

        // Allow network access on main thread (for testing only)
        // TODO: Remodel all database access to run on a separate thread (issue #26)
<span class="fc" id="L173">        StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder().permitAll().build());</span>


        // Load driver
<span class="fc" id="L177">        new net.sourceforge.jtds.jdbc.Driver();</span>
<span class="fc" id="L178">        mConnection = DriverManager.getConnection(dbUrl, properties);</span>
<span class="fc" id="L179">        Log.d(TAG, &quot;Successfully connected to remote database&quot;);</span>

<span class="fc" id="L181">        verifySchema();</span>
        // Set up prepared statements
<span class="fc" id="L183">        mRecipeInsertStatement = mConnection.prepareStatement(RECIPE_INSERT);</span>
<span class="fc" id="L184">        mRecipeSelectStatement = mConnection.prepareStatement(RECIPE_SELECT_TITLE_AUTHOR);</span>
<span class="fc" id="L185">        mRecipeSelectLikeStatement = mConnection.prepareStatement(RECIPE_SELECT_LIKE);</span>
<span class="fc" id="L186">        mRecipeSelectAllStatement = mConnection.prepareStatement(RECIPE_SELECT_ALL);</span>
        // Set up ID counters
<span class="fc" id="L188">        setUpCounters();</span>
<span class="fc" id="L189">    }</span>


    @Override
    public Recipe loadRecipe(String name, String author) throws SQLException {

        // Allow network access on main thread (for testing only)
        // TODO: Remodel all database access to run on a separate thread (issue #26)
<span class="nc" id="L197">        StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder().permitAll().build());</span>

<span class="nc" id="L199">        mRecipeSelectStatement.setString(1, name);</span>
<span class="nc" id="L200">        mRecipeSelectStatement.setString(2, author);</span>
<span class="nc" id="L201">        mRecipeSelectStatement.execute();</span>
<span class="nc" id="L202">        final ResultSet results = mRecipeSelectStatement.getResultSet();</span>
        try {
<span class="nc bnc" id="L204" title="All 2 branches missed.">            if (results.next()) {</span>
<span class="nc" id="L205">                return recipeFromResult(results);</span>
            } else {
<span class="nc" id="L207">                return null;</span>
            }
<span class="nc" id="L209">        } catch (ParseException e) {</span>
<span class="nc" id="L210">            throw new SQLException(&quot;Failed to parse recipe steps&quot;, e);</span>
        } finally {
<span class="nc" id="L212">            results.close();</span>
        }
    }

    @Override
    public List&lt;Recipe&gt; findRecipesLike(String title) throws SQLException {

        // Allow network access on main thread (for testing only)
        // TODO: Remodel all database access to run on a separate thread (issue #26)
<span class="nc" id="L221">        StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder().permitAll().build());</span>

        // Create an expression for any string that contains the query
<span class="nc" id="L224">        final String expression = '%' + title + '%';</span>
<span class="nc" id="L225">        mRecipeSelectLikeStatement.setString(1, expression);</span>
<span class="nc" id="L226">        mRecipeSelectLikeStatement.execute();</span>

<span class="nc" id="L228">        final ResultSet results = mRecipeSelectLikeStatement.getResultSet();</span>
        try {
<span class="nc" id="L230">            return recipesFromResults(results);</span>
        } finally {
<span class="nc" id="L232">            results.close();</span>
        }
    }

    /**
     * Creates a Recipe from a ResultSet
     *
     * @param result the ResultSet to read from. This must already be set to a valid row.
     * @return a Recipe
     * @throws SQLException   if an error occurs
     * @throws ParseException if the steps could not be parsed
     */
    private Recipe recipeFromResult(ResultSet result) throws SQLException, ParseException {
<span class="fc" id="L245">        final long id = result.getLong(&quot;id&quot;);</span>
<span class="fc" id="L246">        final String name = result.getString(&quot;name&quot;);</span>
<span class="fc" id="L247">        final String author = result.getString(&quot;author&quot;);</span>
<span class="fc" id="L248">        final String description = result.getString(&quot;description&quot;);</span>
<span class="fc" id="L249">        final List&lt;Step&gt; steps = mParser.parseRecipeSteps(description);</span>

<span class="fc" id="L251">        final Recipe recipe = new Recipe(name, author, steps);</span>
<span class="fc" id="L252">        recipe.setObjectId(id);</span>
<span class="fc" id="L253">        return recipe;</span>
    }

    /**
     * Creates a list of zero or more recipes from a ResultSet
     *
     * Any recipes that cannot be parsed will be ignored.
     *
     * @param results a result set to read from. This must be positioned before the first row to read.
     * @return the recipes provided by the result set
     * @throws SQLException if an error occurs
     */
    private List&lt;Recipe&gt; recipesFromResults(ResultSet results) throws SQLException {
<span class="fc" id="L266">        final List&lt;Recipe&gt; recipes = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L267" title="All 2 branches covered.">        while (results.next()) {</span>
            try {
<span class="fc" id="L269">                recipes.add(recipeFromResult(results));</span>
<span class="nc" id="L270">            } catch (ParseException e) {</span>
                // TODO: Should this be reported in some other way?
                // Will proceed to the next recipe
<span class="nc" id="L273">                Log.w(TAG, &quot;Failed to parse recipe steps&quot;);</span>
<span class="pc" id="L274">            }</span>
        }
<span class="fc" id="L276">        return recipes;</span>
    }

    @Override
    public void checkInvariants() throws SQLException {
        // No invariants to check for now
<span class="nc" id="L282">    }</span>

    @Override
    public void storeRecipe(Recipe r) throws SQLException {

        // Allow network access on main thread (for testing only)
        // TODO: Remodel all database access to run on a separate thread (issue #26)
<span class="nc" id="L289">        StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder().permitAll().build());</span>

<span class="nc" id="L291">        r.setObjectId(++mRecipeCounter);</span>
<span class="nc" id="L292">        mRecipeInsertStatement.setLong(1, r.getObjectId());</span>
<span class="nc" id="L293">        mRecipeInsertStatement.setString(2, r.getTitle());</span>
<span class="nc" id="L294">        mRecipeInsertStatement.setString(3, r.getAuthor());</span>
<span class="nc" id="L295">        final String description = mParser.serializeRecipeSteps(r.getSteps());</span>
<span class="nc" id="L296">        mRecipeInsertStatement.setString(4, description);</span>

<span class="nc" id="L298">        mRecipeInsertStatement.execute();</span>
<span class="nc" id="L299">    }</span>

    @Override
    public void editRecipe(Recipe r) throws SQLException {
<span class="nc" id="L303">        throw new UnsupportedOperationException(&quot;Not implemented&quot;);</span>
    }

    @Override
    public List&lt;Recipe&gt; loadAllRecipes() throws SQLException {

        // Allow network access on main thread (for testing only)
        // TODO: Remodel all database access to run on a separate thread (issue #26)
<span class="fc" id="L311">        StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder().permitAll().build());</span>

<span class="fc" id="L313">        mRecipeSelectAllStatement.execute();</span>
<span class="fc" id="L314">        final ResultSet results = mRecipeSelectAllStatement.getResultSet();</span>
        try {
<span class="fc" id="L316">            return recipesFromResults(results);</span>
        } finally {
<span class="pc" id="L318">            results.close();</span>
        }
    }

    @Override
    public void deleteRecipe(Recipe r) throws SQLException {
<span class="nc" id="L324">        throw new UnsupportedOperationException(&quot;Not implemented&quot;);</span>
    }

    @Override
    public Bunch loadBunch(String name) throws SQLException {
<span class="nc" id="L329">        throw new UnsupportedOperationException(&quot;Not implemented&quot;);</span>
    }

    @Override
    public void storeBunch(Bunch b) throws SQLException {
<span class="nc" id="L334">        throw new UnsupportedOperationException(&quot;Not implemented&quot;);</span>
    }

    @Override
    public void editBunch(Bunch b) throws SQLException {
<span class="nc" id="L339">        throw new UnsupportedOperationException(&quot;Not implemented&quot;);</span>
    }

    @Override
    public List&lt;Bunch&gt; loadAllBunches() throws SQLException {
<span class="nc" id="L344">        throw new UnsupportedOperationException(&quot;Not implemented&quot;);</span>
    }

    @Override
    public void deleteBunch(Bunch b) throws SQLException {
<span class="nc" id="L349">        throw new UnsupportedOperationException(&quot;Not implemented&quot;);</span>
    }

    @Override
    public void storeLearnerData(Recipe r, Collection&lt;LearningWeight&gt; weights) throws SQLException {
<span class="nc" id="L354">        throw new UnsupportedOperationException(&quot;Not implemented&quot;);</span>
    }

    @Override
    public Collection&lt;LearningWeight&gt; loadLearnerData(Recipe r) throws SQLException {
<span class="nc" id="L359">        throw new UnsupportedOperationException(&quot;Not implemented&quot;);</span>
    }

    @Override
    public void clearAllTables() throws SQLException {
<span class="nc" id="L364">        final Statement statement = mConnection.createStatement();</span>
        try {
<span class="nc" id="L366">            statement.executeUpdate(String.format(Locale.US, &quot;DELETE FROM %s&quot;, RECIPE_TABLE_NAME));</span>
<span class="nc" id="L367">            statement.executeUpdate(String.format(Locale.US, &quot;DELETE FROM %s&quot;, BUNCH_TABLE_NAME));</span>
<span class="nc" id="L368">            statement.executeUpdate(String.format(Locale.US, &quot;DELETE FROM %s&quot;, BUNCH_RECIPE_TABLE_NAME));</span>
        } finally {
<span class="nc" id="L370">            statement.close();</span>
<span class="nc" id="L371">        }</span>
<span class="nc" id="L372">    }</span>

    @Override
    public boolean containsRecipe(long id) throws SQLException {
<span class="nc" id="L376">        throw new UnsupportedOperationException(&quot;Not implemented&quot;);</span>
    }

    /**
     * Sets up the tables if they do not exist
     */
    private void verifySchema() throws SQLException {
<span class="fc" id="L383">        final Statement statement = mConnection.createStatement();</span>
        try {
<span class="fc" id="L385">            statement.executeUpdate(RECIPE_TABLE_CREATE);</span>
<span class="fc" id="L386">            statement.executeUpdate(BUNCH_TABLE_CREATE);</span>
<span class="fc" id="L387">            statement.executeUpdate(BUNCH_RECIPE_TABLE_CREATE);</span>
        } finally {
<span class="pc" id="L389">            statement.close();</span>
<span class="fc" id="L390">        }</span>
<span class="fc" id="L391">    }</span>

    /**
     * Initializes {@link #mRecipeCounter} to one greater than the
     * greatest ID of any recipe in the database. If the recipes table is empty, sets mRecipeCounter
     * to 1.
     */
    private void setUpCounters() throws SQLException {
<span class="fc" id="L399">        final Statement statement = mConnection.createStatement();</span>
        try {
<span class="fc" id="L401">            statement.execute(&quot;SELECT TOP (1) id FROM &quot; + RECIPE_TABLE_NAME + &quot; ORDER BY id DESC&quot;);</span>
<span class="fc" id="L402">            ResultSet results = statement.getResultSet();</span>
<span class="pc bpc" id="L403" title="1 of 2 branches missed.">            if (results.next()) {</span>
<span class="fc" id="L404">                mRecipeCounter = results.getLong(&quot;id&quot;) - 1;</span>
            } else {
<span class="nc" id="L406">                mRecipeCounter = 1;</span>
            }
<span class="fc" id="L408">            results.close();</span>
        } finally {
<span class="pc" id="L410">            statement.close();</span>
<span class="fc" id="L411">        }</span>
<span class="fc" id="L412">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.4.201502262128</span></div></body></html>